%\VignetteIndexEntry{OncoSimulR Overview}
%\VignetteDepends{OncoSimulR}
%\VignetteKeywords{OncoSimulR simulation cancer oncogenetic trees}
%\VignettePackage{OncoSimulR}
%\VignetteEngine{knitr::knitr}
\documentclass[a4paper,11pt]{article}
<<echo=FALSE,results='hide',error=FALSE>>=
require(knitr, quietly = TRUE)
opts_knit$set(concordance = TRUE)
##opts_knit$set(stop_on_error = 2L)
@ 
\usepackage{amsmath}
%% \usepackage[authoryear,round,sort]{natbib}
\usepackage{threeparttable}
\usepackage{array}
%%\usepackage{hyperref} %% not if using BiocStyle
%%ditto
%\usepackage{geometry}
%\geometry{verbose,a4paper,tmargin=23mm,bmargin=26mm,lmargin=28mm,rmargin=28mm}
\usepackage{url}
\usepackage{xcolor}
%\definecolor{light-gray}{gray}{0.72}
\newcommand{\cyan}[1]{{\textcolor {cyan} {#1}}}
\newcommand{\blu}[1]{{\textcolor {blue} {#1}}}
\newcommand{\Burl}[1]{\blu{\url{#1}}}


%%\SweaveOpts{echo=TRUE}

%\usepackage{tikz}
%\usetikzlibrary{arrows,shapes,positioning}

\usepackage[latin1]{inputenc}


\usepackage{gitinfo}

%Uncomment for BioC
%\usepackage{datetime}
%\newdateformat{mydate}{\THEDAY-\monthname[\THEMONTH]-\THEYEAR}

<<style-knitr, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@


%%\title{Using OncoSimulR: a package for simulating cancer progression data,
%%including drivers and passengers, and allowing for order restrictions.}

%%\author{Ramon Diaz-Uriarte\\
%%Dept. Biochemistry, Universidad Aut\'onoma de Madrid \\ 
%%Instituto de Investigaciones Biom\'edicas ``Alberto Sols'' (UAM-CSIC)\\
%%Madrid, Spain\\
%%{\small \texttt{ramon.diaz@iib.uam.es}} \\
%%{\small \texttt{rdiaz02@gmail.com}} \\
%%{\small \Burl{http://ligarto.org/rdiaz}} \\
%%}


\bioctitle{Using OncoSimulR: examples}

%% \bioctitle{Using OncoSimulR: a package for simulating cancer progression data,
%%   including drivers and passengers, and allowing for order restrictions.}

\author{Ramon Diaz-Uriarte\\
  Dept. Biochemistry, Universidad Aut\'onoma de Madrid \\ 
  Instituto de Investigaciones Biom\'edicas ``Alberto Sols'' (UAM-CSIC)\\
  Madrid, Spain{\footnote{ramon.diaz@iib.uam.es, rdiaz02@gmail.com}} \\
%% {\footnote{rdiaz02@gmail.com}} \\
{\small \Burl{http://ligarto.org/rdiaz}} \\
 }
%% \date{\the\year-\the\month-\the\day}
%% \date{\mydate\today}
 \date{\gitAuthorDate\ {\footnotesize (Rev: \gitAbbrevHash)}}
\begin{document}
\maketitle

%% Remember to add BiocStyle to Suggests
%%
%% I get lots of problems, so will try later.
%% <<style, eval=TRUE, echo=FALSE, results=tex>>=
%% BiocStyle::latex()
%% @

\tableofcontents


%%FIXME remove later!
<<>>=
library(OncoSimulR)
library(graph)

source("new-restrict.R")

@ 

\section{Specifying fitness effects}

\subsection{Introduction}

With OncoSimulR you can specify different types of effects on fitness:

\begin{itemize}
\item General epistatic effects (e.g., section \ref{epi}), including
  synthetic viability (e.g., section \ref{sv}) and synthetic
  lethality/mortality (e.g., section \ref{sl}).
  
  
\item Effects where the order in which mutations are acquired matter, as
  illustrated in section \ref{oe}. There is, in fact, empirical evidence
  of these effects \cite{xx}. For instance, the fitness of genotype ``A,
  B'' would differ depending on whether A or B was acquired first. 

\item A special type of epistatic effects that is particularly amenable to
  be represented as a graph. In this graph, having, say, ``B'' be a child
  of ``A'' means that B can only accumulate if A is already present.  This
  is what OT, CBN, etc, blablablabla.
  
  Note that this is not an order effect. If the restrictions in the graph
  are satisfied, how they were satisfied is irrelevant.

\item Genes that have independent effects on fitness.
  
\end{itemize}


\subsubsection{How to specify those effects}

A guiding design principle of OncoSimulR is to try to make the
specification of those effects as simple as possible but also as flexible
as possible. 

Conceptually, the simplest way is to specify the mapping of genotypes to
fitness explicitly. This can be done with OncoSimulR (e.g., see sections
\ref{e2}, \ref{e3} and \ref{theminus} or the example in \ref{weis1b}), but
this only works well for subsets of the genes or for very small genotypes,
as you probably do not want to be explicit about the mapping of $2^k$
genotypes to fitness when $k$ is larger than, say, four or five, and
definitely not when $k$ is 10.


An alternative general approach followed in many genetic simulators is to
specify how particular combinations of alleles modify the wildtype
genotype or the genotype that contains the individual effects of the
interacting genes (e.g., see equation 1 in the supplementary material for
FFPopSim ).  For example, if we specify that ``A'' adds 0.04, ``B'' adds
0.03, and ``A:B'' adds 0.1, that means that the fitness of the ``A, B''
genotype is that of the wildtype (1, by default), plus the effects of A,
plus the effects of B, plus the effects of ``A:B''. 


As we will see in the examples (e.g., see sections\ref{e2}, \ref{e3},
\ref{exlong}) OncoSimulR makes it simple to be explicit about the mapping
of specific genotypes, while also useing the ``how this specific effects
modifies previous effects'' logic, leading to a flexible
specification. This also means that in many cases, the same fitness
effects can be specified in very different ways.



\subsection{Specifying modules}

Why do we force you to specify ``Root'' = ``Root''? We could check for it,
and add it if it is not present. But we want you to be explicit (and we
want to avoid you shooting yourself in the foot having a gene that is not
root but is called ``Root'', etc).

\subsection{What does a module provide}\label{module-what-for}

%% \begin{tabular} {c c c}
%%   A & B & Fitness \\
%%   \hline
%%   wt&wt& 1 \\
%%   wt&M& sb \\
%%   M&wt& sa\\
%%   M&M& sab)\\
%%   \hline
%% \end{tabular}

with A being 1, 2, and B 3, 4.

and having in a tree A depends on Root and B depends on A



\begin{tabular} {c c}
  model & Fitness satisfied & fitness not satisf\\
  \hline
  0 , 1 & s \\
  0 , 2 & s \\

  1 , 3 & s3 & sm \\
  2 , 3 & s3 & sm \\

  1 , 4 & s3 & sm \\
  2 , 4 & s3 & sm \\
  
  1 : 2 & s12 \\
  3:  4 & s34
  

  \hline
\end{tabular}

just give the specification, the full one.


and write equivalendes of s12 as a function of Sa, S34 as a function of
Sb, etc.


\subsection{Order restrictions as posets}


\subsubsection{A first conjunction example}\label{cbn1}

<<>>=

cs <-  data.frame(parent = c(rep("Root", 4), "a", "b", "d", "e", "c"),
                 child = c("a", "b", "d", "e", "c", "c", rep("g", 3)),
                 s = 0.1,
                 sh = -0.9,
                 typeDep = "MN")

fcs <- allFitnessEffects(cs)

@ 

We can get a graphical representation using the default ``graphNEL''
<<>>=
plot(fcs)
@ 

or one using ``igraph'':
<<>>=
plot(fcs, "igraph", layout = layout.reingold.tilford)
@ 

(since this is a tree, the reingold.tilford layout is probably the best here).


And what is the fitness of all genotypes?

<<>>=

gfs <- evalAllGenotypes(fcs, order = FALSE)

gfs[1:15, ]
@

You can verify that for each genotype, if a mutation is present without
all of its dependencies present, you get a $(1 - 0.9)$ multiplier, and you
get a $(1 + 0.1)$ multiplier for all the rest with its direct parents
satisfied. For example, genotypes ``a'', or ``b'', or ``d'', or ``e'' have
fitness $(1 + 0.1)$, genotype ``a, b, c'' has fitness $(1 + 0.1)^3$, but
genotype ``a, c'' has fitness $(1 + 0.1) (1 - 0.9) = 0.11$.



\subsubsection{A second conjunction example}\label{cbn2}



Let's try a first attempt at a somewhat more complex example, where the
fitness consequences of different genes differ.
<<>>=

c1 <- data.frame(parent = c(rep("Root", 4), "a", "b", "d", "e", "c"),
                 child = c("a", "b", "d", "e", "c", "c", rep("g", 3)),
                 s = c(0.01, 0.02, 0.03, 0.04, 0.1, 0.1, rep(0.2, 3)),
                 sh = c(rep(0, 4), c(-.1, -.2), c(-.05, -.06, -.07)),
                 typeDep = "MN")

try(fc1 <- allFitnessEffects(c1))

@ 

That is an error because the ``sh'' varies within a child, and we do not
allow that for a poset-type specification, as it can lead to
ambiguities. If you need arbitrary fitness values for arbitrary
combinations of genotypes, you can specify them using epistatic effects as
in section \ref{epi} and order effects as in section \ref{oe}.


(By the way, yes, we convert all factors to strings in the parent, child,
and typeDep columns, so no need to specify \texttt{stringsAsFactor = TRUE}).



We fix the error in our specification. Notice that the ``sh'' is not set
to $-1$ in these examples. If you want strict compliance with the poset
restrictions, you should set $sh = -1$, but having an $sh > -1$ will lead
to fitnesses that are $> 0$ and, thus, is a way of modeling small
deviations from the poset (see discussion in xx: paperBMC\cite{xx:paper_BMCBionfo}).

In these examples, the reason to set ``sh'' to values larger than $-1$ and
different among the genes is to allow us to easily see the actual,
different, terms that enter into the multiplication of the fitness effects
(and, also, to make it easier to catch bugs).

Note also that for those nodes that depend only on ``Root'' the type of
dependency is irrelevant.

<<>>=

c1 <- data.frame(parent = c(rep("Root", 4), "a", "b", "d", "e", "c"),
                 child = c("a", "b", "d", "e", "c", "c", rep("g", 3)),
                 s = c(0.01, 0.02, 0.03, 0.04, 0.1, 0.1, rep(0.2, 3)),
                 sh = c(rep(0, 4), c(-.9, -.9), rep(-.95, 3)),
                 typeDep = "MN")

fc1 <- allFitnessEffects(c1)

@ 

We can get a graphical representation using the default ``graphNEL''
<<>>=
plot(fc1)
@ 

or one using ``igraph'':
<<>>=
plot(fc1, "igraph", layout = layout.reingold.tilford)
@ 

(since this is a tree, the reingold.tilford layout is probably the best here).

This figures, of course, are the same as in the example in section
\ref{cbn1}, since the structure has not changed, only the numeric values.

What is the fitness of all possible genotypes? Here, order of events
\textit{per se} does not matter, beyond that considered in the poset. In
other words, the fitness of genotype ``a, b, c'' is the same no matter how
we got to ``a, b, c''. What matters is whether or not the genes on which
each of ``a'', ``b'', and ``c'' are present or not (I only show the first
10 genotypes)

<<>>=
gfc1 <- evalAllGenotypes(fc1, order = FALSE)
gfc1[1:10, ]
@ 


Of course, if we were to look at genotypes but taking into account order
of occurrence of mutations, we would see no differences

<<>>=
gfc1o <- evalAllGenotypes(fc1, order = TRUE, max = 1956)
gfc1o[1:10, ]
@ 

You can check the output and verify things are as they should. For instance:

<<>>=
all.equal(
        gfc1[c(1:21, 22, 28, 41, 44, 56, 63 ) , "Fitness"],
        c(1.01, 1.02, 0.1, 1.03, 1.04, 0.05,
          1.01 * c(1.02, 0.1, 1.03, 1.04, 0.05),
          1.02 * c(0.10, 1.03, 1.04, 0.05),
          0.1 * c(1.03, 1.04, 0.05),
          1.03 * c(1.04, 0.05),
          1.04 * 0.05,
          1.01 * 1.02 * 1.1,
          1.01 * 0.1 * 0.05,
          1.03 * 1.04 * 0.05,
          1.01 * 1.02 * 1.1 * 0.05,
          1.03 * 1.04 * 1.2 * 0.1, ## notice this
          1.01 * 1.02 * 1.03 * 1.04 * 1.1 * 1.2
          ))
@ 

A particular one that is important to understand is

<<>>=
gfc1[56, ] ## this is d, e, g, c
gfc1[56, "Fitness"] == 1.03 * 1.04 * 1.2 * 0.10
@ 

where ``g'' is taken as if its dependencies are satisfied (as ``c'',
``d'', and ``e'' are present) even when the dependencies of ``c'' are not
satisfied (and that is why the term for ``c'' is 0.9).


\subsubsection{A semimonotone or ``OR'' example}\label{mn1}

We will reuse the above example, changing the type of relationship:
<<>>=

s1 <- data.frame(parent = c(rep("Root", 4), "a", "b", "d", "e", "c"),
                 child = c("a", "b", "d", "e", "c", "c", rep("g", 3)),
                 s = c(0.01, 0.02, 0.03, 0.04, 0.1, 0.1, rep(0.2, 3)),
                 sh = c(rep(0, 4), c(-.9, -.9), rep(-.95, 3)),
                 typeDep = "SM")

fs1 <- allFitnessEffects(s1)

@ 

It looks like this:
<<>>=
plot(fs1)
@ 


<<>>=
gfs1 <- evalAllGenotypes(fs1, order = FALSE)

@ 

Now, having just one parental dependency satisfied is enough, in contrast
to what happened before. For instance:

<<>>=
gfc1[c(8, 12, 22), ]
gfs1[c(8, 12, 22), ]

gfc1[c(20:21, 28), ]
gfs1[c(20:21, 28), ]
@ 


\subsubsection{An ``XMPN'' or ``XOR'' example}\label{xor1}

Again, we reuse the example above, changing the type of relationship:

<<>>=

x1 <- data.frame(parent = c(rep("Root", 4), "a", "b", "d", "e", "c"),
                 child = c("a", "b", "d", "e", "c", "c", rep("g", 3)),
                 s = c(0.01, 0.02, 0.03, 0.04, 0.1, 0.1, rep(0.2, 3)),
                 sh = c(rep(0, 4), c(-.9, -.9), rep(-.95, 3)),
                 typeDep = "XMPN")

fx1 <- allFitnessEffects(x1)

@ 


It looks like this:
<<>>=
plot(fx1)
@ 

<<>>=

gfx1 <- evalAllGenotypes(fx1, order = FALSE)

@ 


Whenever ``c'' is present with both ``a'' and ``b'', the fitness component
for ``c'' will be $(1 - 0.1)$. Similarly for ``g'' (if more than one of
``d'', ``e'', or ``c'' is present, it will show as $(1 - 0.05)$). For example:

<<>>=
gfx1[c(22, 41), ] 
c(1.01 * 1.02 * 0.1, 1.03 * 1.04 * 0.05)
@ 

However, having just both ``a'' and ``b'' is identical to the case with
CBN and the monotone relationship (see sections \ref{cbn2} and
\ref{mn1}). If you want the joint presence of ``a'' and ``b'' to result in
different fitness, you can specify that using general epistatic effects
(section \ref{epi}); XOR relationships of these kind are, actually,
examples of synthetic lethality, which are shown in section \ref{sl}.


We also see a very different pattern compared to CBN (section \ref{cbn2})
here:
<<>>=
gfx1[28, ] 
1.01 * 1.1 * 1.2
@ 
as ``c'' is satisfied by one, and ``g'' too, this is in the
``semimonotone'' situatione.

But 
<<>>=
gfx1[44, ] 
1.01 * 1.02 * 0.1 * 1.2
@ 
is the result of a $0.1$ for ``c'' (and a $1.2$ for ``g'' that has exactly
one of its dependencies satisfied).


\subsubsection{Posets: the three types of relationships}\label{p3}

<<>>=

p3 <- data.frame(parent = c(rep("Root", 4), "a", "b", "d", "e", "c", "f"),
                  child = c("a", "b", "d", "e", "c", "c", "f", "f", "g", "g"),
                  s = c(0.01, 0.02, 0.03, 0.04, 0.1, 0.1, 0.2, 0.2, 0.3, 0.3),
                  sh = c(rep(0, 4), c(-.9, -.9), c(-.95, -.95), c(-.99, -.99)),
                  typeDep = c(rep("--", 4), 
                      "XMPN", "XMPN", "MN", "MN", "SM", "SM"))
fp3 <- allFitnessEffects(p3)
@ 

This is how it looks like:
<<>>=
plot(fp3)
@ 

We can also use ``igraph'':

<<>>=
plot(fp3, "igraph", layout.reingold.tilford)
@ 


<<>>=

gfp3 <- evalAllGenotypes(fp3, order = FALSE)

@ 



Let's look at a few:
<<>>=
gfp3[c(9, 24, 29, 59, 60, 66, 119, 120, 126, 127), ]

c(1.01 * 1.1, 1.03 * .05, 1.01 * 1.02 * 0.1, 0.1 * 0.05 * 1.3,
  1.03 * 1.04 * 1.2, 1.01 * 1.02 * 0.1 * 0.05,
  0.1 * 1.03 * 1.04 * 1.2 * 1.3,
  1.01 * 1.02 * 0.1 * 1.03 * 1.04 * 1.2,
  1.02 * 1.1 * 1.03 * 1.04 * 1.2 * 1.3,
  1.01 * 1.02 * 1.03 * 1.04 * 0.1 * 1.2 * 1.3)

@ 

As before, looking at the order of mutations makes no difference (look at
the test directory to see a test that verifies this assertion).


\subsubsection{Posets: the three types of relationships and modules}\label{pm3}

We can of course add modules. Beware that the number of genotypes is
starting to grow quite fast, though. We use the same specification of
poset, but add modules. To keep it manageable, we only add a few genes for
some modules, and have some modules with a single gene. We capitalize to
differentiate modules (capital letters) from genes (lowercase with a number).

<<>>=
p4 <- data.frame(parent = c(rep("Root", 4), "A", "B", "D", "E", "C", "F"),
                  child = c("A", "B", "D", "E", "C", "C", "F", "F", "G", "G"),
                  s = c(0.01, 0.02, 0.03, 0.04, 0.1, 0.1, 0.2, 0.2, 0.3, 0.3),
                  sh = c(rep(0, 4), c(-.9, -.9), c(-.95, -.95), c(-.99, -.99)),
                  typeDep = c(rep("--", 4), 
                      "XMPN", "XMPN", "MN", "MN", "SM", "SM"))
fp4m <- allFitnessEffects(p4,
                          geneToModule = c("Root" = "Root", "A" = "a1",
                              "B" = "b1, b2", "C" = "c1",
                              "D" = "d1, d2", "E" = "e1",
                              "F" = "f1, f2", "G" = "g1"))
@ 

Plotting is simple
<<>>=
plot(fp4m)
@ 

and we can show the gene names instead of the module names:

<<>>=
plot(fp4m, expandModules = TRUE)
@ 

or

<<>>=
plot(fp4m, "igraph", layout = layout.reingold.tilford, 
     expandModules = TRUE)

@ 

We obtain the fitness of all genotypes in the usual way:
<<>>=
gfp4 <- evalAllGenotypes(fp4m, order = FALSE, max = 1024)
@ 

Let's look at a few of those:
<<>>=
gfp4[c(12, 20, 21, 40, 41, 46, 50, 55, 64, 92, 155, 157, 163, 372, 632, 828), ]

c(1.01 * 1.02, 1.02, 1.02 * 1.1, 0.1 * 1.3, 1.03, 
  1.03 * 1.04, 1.04 * 0.05, 0.05 * 1.3,  
  1.01 * 1.02 * 0.1, 1.02 * 1.1, 0.1 * 0.05 * 1.3,
  1.03 * 0.05, 1.03 * 0.05, 1.03 * 1.04 * 1.2, 1.03 * 1.04 * 1.2, 
  1.02 * 1.1 * 1.03 * 1.04 * 1.2 * 1.3)

@ 



\subsection{Order effects} \label{oe}
\subsubsection{Order effects: three-gene orders}

Consider this case, where three specific three-gene-orders and two
two-gene orders (one of them a subset of one of the three) lead to
different fitness compared to the wild-type. We add also modules, to show
it usage (but just limit ourselves to using one gene per module here):

<<>>=

o3 <- allFitnessEffects(orderEffects = c(
                            "F > D > M" = -0.3,
                            "D > F > M" = 0.4,
                            "D > M > F" = 0.2,
                            "D > M"     = 0.1,
                            "M > D"     = 0.5),
                        geneToModule =
                            c("Root" = "Root",
                              "M" = "m",
                              "F" = "f",
                              "D" = "d") )


(ag <- evalAllGenotypes(o3))
@ 

The values for the first nine genotypes come directly from the fitness
specifications. The 10th genotype matches ``D > F > M'' ($= (1 + 0.4)$)
but also ``D > M'' ($(1 + 0.1)$). The 11th matches ``D > M > F'' and ``D >
M''. The 12th matches ``F > D > M'' but also ``D > M''. Etc.




\subsubsection{Order effects and modules}

Consider the following case:
<<>>=
ofe1 <- allFitnessEffects(orderEffects = c("F > D" = -0.3, "D > F" = 0.4),
                          geneToModule =
                              c("Root" = "Root",
                                "F" = "f1, f2",
                                "D" = "d1, d2") )

ag <- evalAllGenotypes(ofe1)

@ 

There are four genes, $d1, d2, f1, f2$, where each $d$ belongs to module
$D$ and each $f$ belongs to module $F$.

What to expect for cases such as $d1 > f1$ or $f1 > d1$ is clear, as shown in

<<>>=
ag[5:16,]
@ 

Likewise, cases such as $d1 > d2 > f1$ or $f2 > f1 > d1$ are clear,
because in terms of modules they map to $ D > F$ or $F > D$: the observed
order of mutation $d1 > d2 > f1$ means that module $D$ was mutated first
and module $F$ was mutated second. Similar for $d1 > f1 > f2$ or
$f1 > d1 > d2$: those map to $D > F$ and $F > D$. We can see the fitness
of those four case in:

<<>>=
ag[c(17, 39, 19, 29), ]
@ 

and they correspond to the values of those order effects, where $F > D =
(1 - 0.3)$ and $D > F = (1 + 0.4)$:

<<>>=
ag[c(17, 39, 19, 29), "Fitness"] == c(1.4, 0.7, 1.4, 0.7)
@ 

What if we match several patterns? For example, $d1 > f1 > d2 > f2$ and
$d1 > f1 > f2 > d2$? The first maps to $D > F > D > F$ and the second to
$D > F > D$. But since we are concerned with which one happened first and
which happened second we should expect those two to correspond to the same
fitness, that of pattern $D > F$, as is the case:

<<>>=
ag[c(43, 44),]
ag[c(43, 44), "Fitness"] == c(1.4, 1.4)
@ 
More generally, that applies to all the patterns that start with one of
the ``d'' genes:
<<>>=
all(ag[41:52, "Fitness"] == 1.4)
@ 

Similar arguments apply to the opposite pattern, $F > D$, which apply to
all the possible gene mutation orders that start with one of the ``f''
genes. For example:
<<>>=
all(ag[53:64, "Fitness"] == 0.7)
@ 



\subsubsection{Order and modules with 325 genotypes}
We can of course have more than two genes per module. This just repeats
the above, with five genes (there are 325 genotypes, and that is why we
pass the ``max'' argument, to allow for more than the default 256).

<<>>=

ofe2 <- allFitnessEffects(orderEffects = c("F > D" = -0.3, "D > F" = 0.4),
                          geneToModule =
                              c("Root" = "Root",
                                "F" = "f1, f2, f3",
                                "D" = "d1, d2") )
ag2 <- evalAllGenotypes(ofe2, max = 325)

@ 

We can verify that any combination that starts with a ``d'' gene and then
contains at least one ``f'' gene will have  a fitness of $1+0.4$.  And any
combination that starts with an ``f'' gene and contains at least one ``d''
genes will have a fitness of $1 - 0.3$.  All other genotypes have a
fitness of 1:

<<>>=
all(ag2[grep("^d.*f.*", ag2[, 1]), "Fitness"] == 1.4)
all(ag2[grep("^f.*d.*", ag2[, 1]), "Fitness"] == 0.7)
oe <- c(grep("^f.*d.*", ag2[, 1]), grep("^d.*f.*", ag2[, 1]))
all(ag2[-oe, "Fitness"] == 1)
@ 

\subsection{Genes without interactions}\label{noint}

Let's use three genes. We know there are no order effects, but we will
also see what happens if we examine genotypes as ordered.

<<>>=

ai1 <- evalAllGenotypes(allFitnessEffects(
    noIntGenes = c(0.05, -.2, .1)), order = FALSE)
@ 


We can easily verify the first results:

<<>>=
ai1
@ 

<<>>=

all(ai1[, "Fitness"]  == c( (1 + .05), (1 - .2), (1 + .1),
       (1 + .05) * (1 - .2),
       (1 + .05) * (1 + .1),
       (1 - .2) * (1 + .1),
       (1 + .05) * (1 - .2) * (1 + .1)))

@ 

And we can see that considering the order of mutations makes no difference:
<<>>=

ai2 <- evalAllGenotypes(allFitnessEffects(
    noIntGenes = c(0.05, -.2, .1)), order = TRUE)

ai2
@ 


\subsection{Order effects and genes without interactions}

We will now look at both order effects and interactions. To make things
more interesting, we name genes so that the ordered names do split nicely
between those with and those without order effects (this, thus, also
serves as a test of messy orders of names).

<<>>=

foi1 <- allFitnessEffects(
    orderEffects = c("D>B" = -0.2, "B > D" = 0.3),
    noIntGenes = c("A" = 0.05, "C" = -.2, "E" = .1))

@ 

You can get a verbose view of what the gene names and modules are (and
their automatically created numeric codes) by:

<<>>=
foi1[c("geneModule", "long.geneNoInt")]
@ 

We can get the fitness of all genotypes (we set $max = 325$ because that
is the number of possible genotypes):

<<>>=
agoi1 <- evalAllGenotypes(foi1,  max = 325)
head(agoi1)
@ 



Now:
<<>>=
rn <- 1:nrow(agoi1)
names(rn) <- agoi1[, 1]

agoi1[rn[LETTERS[1:5]], "Fitness"] == c(1.05, 1, 0.8, 1, 1.1)

@ 

According to the fitness effects we have specified, we also know that any
genotype with only two mutations, one of which is either ``A'', ``C'' or
``E'' and the other is ``B'' or ``D'' will have the fitness corresponding
to ``A'', ``C'' or ``E'', respectively:

<<>>=
agoi1[grep("^A > [BD]$", names(rn)), "Fitness"] == 1.05
agoi1[grep("^C > [BD]$", names(rn)), "Fitness"] == 0.8
agoi1[grep("^E > [BD]$", names(rn)), "Fitness"] == 1.1
agoi1[grep("^[BD] > A$", names(rn)), "Fitness"] == 1.05
agoi1[grep("^[BD] > C$", names(rn)), "Fitness"] == 0.8
agoi1[grep("^[BD] > E$", names(rn)), "Fitness"] == 1.1
@ 


We will not be doing many additional games with regular expressions, but
let us check those that start with ``D'' and have all the other mutations,
which occupy rows 230 to 253; fitness should be equal (within numerical
error, because of the non-commutativity of floating point
multiplication) to the order effect of having ``D'' before ``B''  times
the other effects $(1 - 0.3) * 1.05 * 0.8 * 1.1 = 0.7392$

<<>>=
all.equal(agoi1[230:253, "Fitness"] , rep((1 - 0.3) * 1.05 * 0.8 * 1.1, 24))
@ 
and that will also be the value of any genotype with the five mutations
where ``D'' comes before ``B'' such as those in rows 260 to 265, 277, or
322 and 323, but it will be equal to $(1 + 0.3) * 1.05 * 0.8 * 1.1 =
1.2012$ in those where ``B'' comes before ``D''. Analogous arguments apply
to four, three, and two mutation genotypes.





\subsection{Synthetic viability}\label{sv}

Synthetic viability and synthetic lethality \cite{xx} are just special
cases of epistasis (section \ref{epi}) but we deal with them here
separately. 

\subsubsection{A simple synthetic viability example}
A simple example of synthetic viability \cite{xx} is shown in the
following table:


\begin{tabular} {c c c}
  A & B & Fitness \\
  \hline
  wt&wt& 1 \\
  wt&M& 0 \\
  M&wt& 0\\
  M&M& (1 + s)\\
  \hline
\end{tabular}
where ``wt'' denotes wild type and ``M'' denotes mutant.


We can specify this (setting $s = 0.2$) as (I play around with spaces, to
show there is a certain flexibility with them):

<<>>=
s <- 0.2
sv <- allFitnessEffects(epistasis = c("-A : B" = -1,
                                      "A : -B" = -1,
                                      "A:B" = s))
@ 

Now, let's look at all the genotypes (we use ``addwt'' to also get the wt,
which by decree has fitness of 1), and disregard order:

<<>>=
(asv <- evalAllGenotypes(sv, order = FALSE, addwt = TRUE))
@ 

Asking the program to consider the order of mutations of course makes no
difference:

<<>>=
evalAllGenotypes(sv, order = TRUE, addwt = TRUE)
@ 

Another example is shown in section \ref{misra1b}.


\subsubsection{Synthetic viability, non-zero fitness and modules}

This is a slightly more elaborate case, where there is one module and the
single mutants have different fitness between themselves, which is
non-zero. Without the modules, this is the same as in Misra et
al. \cite{xx}, Figure 1b.


\begin{tabular} {c c c}
  A & B & Fitness \\
  \hline
  wt&wt& 1 \\
  wt&M& $1 + s_b$0 \\
  M&wt& $1 + s_a$\\
  M&M& $1 + s_{ab}$\\
  \hline
\end{tabular}

where $s_a, s_b < 0$ but $s_{ab} > 0$. 


<<>>=
sa <- -0.1
sb <- -0.2
sab <- 0.25
sv2 <- allFitnessEffects(epistasis = c("-A : B" = sb,
                             "A : -B" = sa,
                             "A:B" = sab),
                         geneToModule = c(
                             "Root" = "Root",
                             "A" = "a1, a2",
                             "B" = "b"))
evalAllGenotypes(sv2, order = FALSE, addwt = TRUE)
@ 

And if we look at order, of course it makes no difference:

<<>>=
evalAllGenotypes(sv2, order = TRUE, addwt = TRUE)
@ 

%% And it looks like:

%% <<>>=
%% plot(sv2)
%% @ 

%% a fairly simple plot.

\subsection{Synthetic mortality or synthetic lethality}\label{sl}

This is like a revert pattern with respect to synthetic viability in
section \ref{sv}.

\begin{tabular} {c c c}
  A & B & Fitness \\
  \hline
  wt&wt& 1 \\
  wt&M& $1 + s_b$0 \\
  M&wt& $1 + s_a$\\
  M&M& $1 + s_{ab}$\\
  \hline
\end{tabular}

where $s_a, s_b > 0$ but $s_{ab} < 0$. 


<<>>=
sa <- 0.1
sb <- 0.2
sab <- -0.8
sm1 <- allFitnessEffects(epistasis = c("-A : B" = sb,
                             "A : -B" = sa,
                             "A:B" = sab))
evalAllGenotypes(sm1, order = FALSE, addwt = TRUE)

@ 

And if we look at order, of course it makes no difference:

<<>>=
evalAllGenotypes(sm1, order = TRUE, addwt = TRUE)
@ 

\subsection{Epistasis}\label{epi}

\subsubsection{Epistasis: two alternative specifications}\label{e2}

We want this

\begin{tabular} {c c c}
  A & B & Fitness \\
  \hline
  wt&wt& 1 \\
  wt&M& $1 + s_b$0 \\
  M&wt& $1 + s_a$\\
  M&M& $1 + s_{ab}$\\
  \hline
\end{tabular}
 
Suppose that the actual numerical values are $s_a = 0.2, s_b = 0.3, s_{ab}
= 0.7$.

We specify the above as follows: 
<<>>=
sa <- 0.2
sb <- 0.3
sab <- 0.7

e2 <- allFitnessEffects(epistasis =
                            c("A: -B" = sa,
                              "-A:B" = sb,
                              "A : B" = sab))
evalAllGenotypes(e2, order = FALSE, addwt = TRUE)

@ 

That uses the ``-'' specification, so we explicitly exclude some patterns. 

But we can also use a specification where we do not use the ``-''. That
requires rewriting the interaction term as genotype ``A is mutant, B is
mutant'' will incorporate the effects of ``A mutant'', ``B mutant'' and
``both A and B mutants''. We can define a new $s_2$ that satisfies
$(1 + s_2) = (1 + s_{ab})/((1 + s_a) (1 + s_b))$ and therefore specify as:

<<>>=
s2 <- ((1 + sab)/((1 + sa) * (1 + sb))) - 1

e3 <- allFitnessEffects(epistasis =
                            c("A" = sa,
                              "B" = sb,
                              "A : B" = s2))
evalAllGenotypes(e3, order = FALSE, addwt = TRUE)

@ 

Note that this is the way you would specify effects with FFPopsim
\cite{xx}. Whether this specification or the previous one with ``-'' is
simpler will depend on the model. For synthetic mortality and viability, I
think the one using ``-'' is simpler to map genotype tables to fitness
effects. See also section \ref{theminus} and \ref{e3} and the example in
section \ref{weis1b}.


Finally, note that we can also specify some of these effects by combining
the graph and the epistasis, as shown in section \ref{misra1a} or
\ref{weis1b}.

\subsubsection{Epistasis with three genes and two alternative specifications}\label{e3}

Suppose we have 

\begin{tabular} {c c c c}
  A & B & C & Fitness \\
  \hline
  M & wt & wt & $1 + s_a$ \\
  wt& M & wt& $1 + s_b$ \\
  wt & wt & M & $1 + s_c$ \\
  M & M & wt & $1 + s_{ab}$ \\
  wt& M & M& $1 + s_{bc}$ \\
  M & wt & M & $(1 + s_a) (1 + s_c)$ \\
  M & M & M & $1 + s_{abc}$ \\
  \hline
\end{tabular}

where missing rows have a fitness of 1 (they have been deleted for
conciseness). Note that the mutant for exactly A and C has a fitness that
is the product of the individual terms (so there is no epistasis in that case).


<<>>=
sa <- 0.1
sb <- 0.15
sc <- 0.2
sab <- 0.3
sbc <- -0.25
sabc <- 0.4

sac <- (1 + sa) * (1 + sc) - 1

E3A <- allFitnessEffects(epistasis =
                            c("A:-B:-C" = sa,
                              "-A:B:-C" = sb,
                              "-A:-B:C" = sc,
                              "A:B:-C" = sab,
                              "-A:B:C" = sbc,
                              "A:-B:C" = sac,
                              "A : B : C" = sabc)
                                                )

evalAllGenotypes(E3A, order = FALSE, addwt = FALSE)


@ 

We needed to pass the $s_{ac}$ coefficient explicitly, even if it that
term was just the product. We can try to avoid using the ``-'', however
(but we will need to do other calculations). For simplicity, I use capital
``S'' in what follows where the letters differ:


<<>>=

sa <- 0.1
sb <- 0.15
sc <- 0.2
sab <- 0.3
Sab <- ( (1 + sab)/((1 + sa) * (1 + sb))) - 1
Sbc <- ( (1 + sbc)/((1 + sb) * (1 + sc))) - 1
Sabc <- ( (1 + sabc)/( (1 + sa) * (1 + sb) * (1 + sc) * (1 + Sab) * (1 + Sbc) ) ) - 1

E3B <- allFitnessEffects(epistasis =
                             c("A" = sa,
                               "B" = sb,
                               "C" = sc,
                               "A:B" = Sab,
                               "B:C" = Sbc,
                               ## "A:C" = sac, ## not needed now
                               "A : B : C" = Sabc)
                                                )
evalAllGenotypes(E3B, order = FALSE, addwt = FALSE)

@ 

The above two are, of course, identical:

<<>>=
all(evalAllGenotypes(E3A, order = FALSE, addwt = FALSE) == 
    evalAllGenotypes(E3B, order = FALSE, addwt = FALSE))
@ 

We avoid specifying the ``A:C'', as it just follows from the individual
``A'' and ``C'' terms, but given a specified genotype table, we need to do
a little bit of addition and multiplication to get the coefficients. 


\subsubsection{Why can we specify some effects with a ``-''?}\label{theminus}
Let's think we want to specify the synthetic viability example seen before:

\begin{tabular} {c c c}
  A & B & Fitness \\
  \hline
  wt&wt& 1 \\
  wt&M& 0 \\
  M&wt& 0\\
  M&M& (1 + s)\\
  \hline
\end{tabular}


where ``wt'' denotes wild type and ``M'' denotes mutant.

If you want to directly map the above table to the fitness table for the
program, to specify the genotype ``A is wt, B is a mutant'' you can
specify it as \texttt{``-A,B''}, not just as \texttt{``B''}. Why? Because
just the presence of a ``B'' is also compatible with genotype ``A is
mutant and B is mutant''.  If you use ``-'' you are explicitly saying what
should not be there so that ``-A,B'' is NOT compatible with ``A, B''
. Otherwise, you need to carefully add coefficients.  Depending on what
you are trying to model, different specifications might be simpler. See
the examples in section \ref{e2} and \ref{e3}. You have both options.




\subsubsection{Epistasis: modules}
There is nothing conceptually new, but we will show an example here:

<<>>=

sa <- 0.2
sb <- 0.3
sab <- 0.7

em <- allFitnessEffects(epistasis =
                            c("A: -B" = sa,
                              "-A:B" = sb,
                              "A : B" = sab),
                        geneToModule = c("Root" = "Root",
                                         "A" = "a1, a2",
                                         "B" = "b1, b2"))
evalAllGenotypes(em, order = FALSE, addwt = TRUE)
@ 


Of course, we can do the same thing without using the ``-'', as in section \ref{e2}:

<<>>=
s2 <- ((1 + sab)/((1 + sa) * (1 + sb))) - 1

em2 <- allFitnessEffects(epistasis =
                            c("A" = sa,
                              "B" = sb,
                              "A : B" = s2),
                         geneToModule = c("Root" = "Root",
                                         "A" = "a1, a2",
                                         "B" = "b1, b2")
                         )
evalAllGenotypes(em2, order = FALSE, addwt = TRUE)

@ 


\subsection{Poset, epistasis, synthetic mortality and viability, order
  effects and genes without interactions, with some modules}\label{exlong}

We will now put together a complex example. We will use the poset from
section \ref{pm3} but will also add:
\begin{itemize}
\item Order effects that involve genes in the poset. In this case, if C
  happens before F, fitness decreases by $1 - 0.1$. If it happens the
  other way around, there is no effect on fitness beyond their individual
  contributions. %%  but if it happens the
  %% other way around it increases by $1 + 0.13$.
\item Order effects that involve two new modules, ``H'' and ``I'' (with
  genes ``h1, h2'' and ``i1'', respectively), so that if H happens before
  I fitness increases by $1 + 0.12$.
\item Synthetic mortality between modules ``I'' (already present in the
  epistatic interaction) and ``J'' (with genes ``j1'' and ``j2''): the
  joint presence of these modules leads to cell death (fitness of 0).
\item Synthetic viability between modules ``K'' and ``M'' (with genes
  ``k1'', ``k2'' and ``m1'', respectively), so that their joint presence
  is viable but adds nothing to fitness (i.e., mutation of both has
  fitness $1$), whereas each single mutant has a fitness of $1 - 0.5$.
\item A set of 5 driver genes ($n1, \ldots, n5$) with fitness that comes
  from an exponential distribution.
\end{itemize}



As we are specifying many different things, we will start by writing each
set of effects separately:


<<>>=

p4 <- data.frame(parent = c(rep("Root", 4), "A", "B", "D", "E", "C", "F"),
                 child = c("A", "B", "D", "E", "C", "C", "F", "F", "G", "G"),
                 s = c(0.01, 0.02, 0.03, 0.04, 0.1, 0.1, 0.2, 0.2, 0.3, 0.3),
                 sh = c(rep(0, 4), c(-.9, -.9), c(-.95, -.95), c(-.99, -.99)),
                 typeDep = c(rep("--", 4), 
                     "XMPN", "XMPN", "MN", "MN", "SM", "SM"))

oe <- c("C > F" = -0.1, "H > I" = 0.12)
sm <- c("I:J"  = -1)
sv <- c("-K:M" = -.5, "K:-M" = -.5)
epist <- c(sm, sv)

modules <- c("Root" = "Root", "A" = "a1",
             "B" = "b1, b2", "C" = "c1",
             "D" = "d1, d2", "E" = "e1",
             "F" = "f1, f2", "G" = "g1",
             "H" = "h1, h2", "I" = "i1",
             "J" = "j1, j2", "K" = "k1, k2", "M" = "m1")

set.seed(1) ## for repeatability
noint <- rexp(5, 10)
names(noint) <- paste0("n", 1:5)

fea <- allFitnessEffects(rT = p4, epistasis = epist, orderEffects = oe,
                         noIntGenes = noint, geneToModule = modules)

@ 


How does it look?

<<>>=
plot(fea)
@ 

or

<<>>=
plot(fea, "igraph")
@ 


We can, if we want, expand the modules using a ``graphNEL'' graph
<<>>=
plot(fea, expandModules = TRUE)
@ 

or an ``igraph'' one:g
<<>>=
plot(fea, "igraph", expandModules = TRUE)
@ 


We will not evaluate the fitness of all genotypes, since the number of all
order genotypes is $> 7*10^{22}$. We will look at some specific genotypes:

<<>>=
evalGenotype("k1 > i1 > h2", fea) ## 0.5
evalGenotype("k1 > h1 > i1", fea) ## 0.5 * 1.12

evalGenotype("k2 > m1 > h1 > i1", fea) ## 1.12

evalGenotype("k2 > m1 > h1 > i1 > c1 > n3 > f2", fea) 
## 1.12 * 0.1 * (1 + noint[3]) * 0.05 * 0.9

@ 

Finally, let's generate some genotypes randomly:

<<>>=

randomGenotype <- function(fe, ns = NULL) {
    gn <- setdiff(c(fe$geneModule$Gene,
                    fe$long.geneNoInt$Gene), "Root")
    if(is.null(ns)) ns <- sample(length(gn), 1)
    return(paste(sample(gn, ns), collapse = " > "))
}

set.seed(2) ## for reproducibility

evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  k2 > i1 > c1 > n1 > m1
##  Individual s terms are : 0.0755182 -0.9
##  Fitness:  0.107552 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  n2 > h1 > h2
##  Individual s terms are : 0.118164
##  Fitness:  1.11816 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  d2 > k2 > c1 > f2 > n4 > m1 > n3 > f1 > b1 > g1 > n5 > h1 > j2
##  Individual s terms are : 0.0145707 0.0139795 0.0436069 0.02 0.1 0.03 -0.95 0.3 -0.1
##  Fitness:  0.0725829 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  h2 > c1 > f1 > n2 > b2 > a1 > n1 > i1
##  Individual s terms are : 0.0755182 0.118164 0.01 0.02 -0.9 -0.95 -0.1 0.12
##  Fitness:  0.00624418 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  h2 > j1 > m1 > d2 > i1 > b2 > k2 > d1 > b1 > n3 > n1 > g1 > h1 > c1 > k1 > e1 > a1 > f1 > n5 > f2
##  Individual s terms are : 0.0755182 0.0145707 0.0436069 0.01 0.02 -0.9 0.03 0.04 0.2 0.3 -1 -0.1 0.12
##  Fitness:  0 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  n1 > m1 > n3 > i1 > j1 > n5 > k1
##  Individual s terms are : 0.0755182 0.0145707 0.0436069 -1
##  Fitness:  0 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  d2 > n1 > g1 > f1 > f2 > c1 > b1 > d1 > k1 > a1 > b2 > i1 > n4 > h2 > n2
##  Individual s terms are : 0.0755182 0.118164 0.0139795 0.01 0.02 -0.9 0.03 -0.95 0.3 -0.5
##  Fitness:  0.00420528 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  j1 > f1 > j2 > a1 > n4 > c1 > n3 > k1 > d1 > h1
##  Individual s terms are : 0.0145707 0.0139795 0.01 0.1 0.03 -0.95 -0.5
##  Fitness:  0.0294308 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  n5 > f2 > f1 > h2 > n4 > c1 > n3 > b1
##  Individual s terms are : 0.0145707 0.0139795 0.0436069 0.02 0.1 -0.95
##  Fitness:  0.0602298 
evalGenotype(randomGenotype(fea), fea, echo = TRUE, verbose = TRUE)
## Genotype:  h1 > d1 > f2
##  Individual s terms are : 0.03 -0.95
##  Fitness:  0.0515 


@ 

\section{Some examples from the literature}
\subsection{Bauer et al}

In the model of \cite[p.\ 54]{Bauer2014} ``For cells without the primary
driver mutation, each secondary driver mutation leads to a change in the
cell's fitness by $s_P$. For cells with the primary driver mutation, the
fitness advantage obtained with each secondary driver mutation is $s_{DP}$.''

The proliferation probability is given as $(1 + s_p)^k$ when there are $k$
secondary drivers mutated and no primary diver. If the primary driver is
mutated, then the expression is $\frac{1+S_D^+}{1+S_D^-} (1 + S_{DP})^k$.
They set apoptosis as $1 - proliferation$.  So, forgetting constants such
as $1/2$, and setting $ P = \frac{1+S_D^+}{1+S_D^-}$ we can prepare a
table as (for a largest $k$ of 5 in this example, but can make it
arbitrarily large):

<<>>=

K <- 5
sd <- 0.1
sdp <- 0.15
sp <- 0.05
bauer <- data.frame(parent = c("Root", rep("p", K)),
                    child = c("p", paste0("s", 1:K)),
                    s = c(sd, rep(sdp, K)),
                    sh = c(0, rep(sp, K)),
                    typeDep = "MN",
                    stringsAsFactors = FALSE)
fb <- allFitnessEffects(bauer)

@ 

Note that what we specify as ``typeDep'' is irrelevant (MN, SMN, or XMPN
make no difference).


The fitness effects figure looks like this:
<<>>=
plot(fb)
@ 

<<>>=
b1 <- evalAllGenotypes(fb, order = FALSE)
@ 

Order makes no difference

<<>>=
b2 <- evalAllGenotypes(fb, order = TRUE, max = 2000)
@ 

And number of levels is right one: 11
<<>>=
length(table(b1$Fitness))
length(table(b2$Fitness))
@ 


\subsubsection{Bauer et al.\ specified only via epistatic interactions}
Yes, do it: as -p,s1, and -p,s2, etc. But much more of a mess.

\subsubsection{Adding modules to Bauer et al.}

Can we use modules in this module? Sure, as in any other.



\subsection{Misra et al., 2014}\label{misra}

In \cite{xx} present in Figure 1 three scenarios which are different types
of epistasis. 

\subsubsection{Example 1.a}\label{misra1a}
<<echo=FALSE>>=
df1 <- data.frame(x = c(1, 1.2, 1.4), f = c(1, 1.2, 1.2),
                 names = c("wt", "A", "B"))
plot(df1[, 2] ~ df1[, 1], axes = FALSE)
segments(1, 1, 1.2, 1.2)
segments(1, 1, 1.4, 1.2)
text(1, 1, "wt", pos = 4)
text(1.2, 1.2, "A", pos = 2)
text(1.4, 1.2, "B", pos = 2)

@ 


In that figure it is evident that the fitness effect of ``A'' and ``B''
are the same. There are two different models depending on whether ``AB''
is just the product of both, or there is epistasis. In the first case
probably the simplest is:

<<>>=
s <- 0.1 ## or whatever number
m1a1 <- allFitnessEffects(data.frame(parent = c("Root", "Root"),
                                     child = c("A", "B"),
                                     s = s,
                                     sh = 0,
                                     typeDep = "MN"))
evalAllGenotypes(m1a1, order = FALSE, addwt = TRUE)
@ 


If the double mutant shows epistasis, as we saw before (section \ref{e2})
we have a range of options. For example:

<<>>=
s <- 0.1
sab <- 0.3
m1a2 <- allFitnessEffects(epistasis = c("A:-B" = s,
                                        "-A:B" = s,
                                        "A:B" = sab))
evalAllGenotypes(m1a2, order = FALSE, addwt = TRUE)
@ 

But we could also modify the graph dependency structure, and we have to
change the value of the coefficient, since that is what multiplies each of
the terms for ``A'' and ``B'': $(1 + s_{AB}) = (1 + s)^2(1 + s_{AB3}) $

<<>>=
sab3 <- ((1 + sab)/((1 + s)^2)) - 1
m1a3 <- allFitnessEffects(data.frame(parent = c("Root", "Root"),
                                     child = c("A", "B"),
                                     s = s,
                                     sh = 0,
                                     typeDep = "MN"),
                          epistasis = c("A:B" = sab3))
evalAllGenotypes(m1a3, order = FALSE, addwt = TRUE)
@ 

And, obviously
<<>>=
all.equal(evalAllGenotypes(m1a2, order = FALSE, addwt = TRUE),
          evalAllGenotypes(m1a3, order = FALSE, addwt = TRUE))
@ 


\subsubsection{Example 1.b}\label{misra1b}

This is a specific case of synthetic viability (see also section \ref{sv}):

<<echo=FALSE>>=

df1 <- data.frame(x = c(1, 1.2, 1.2, 1.4), f = c(1, 0.4, 0.3, 1.3),
                 names = c("wt", "A", "B", "AB"))
plot(df1[, 2] ~ df1[, 1], axes = FALSE)
segments(1, 1, 1.2, 0.4)
segments(1, 1, 1.2, 0.3)
segments(1.2, 0.4, 1.4, 1.3)
segments(1.2, 0.3, 1.4, 1.3)
text(x = df1[, 1], y = df1[, 2], labels = df1[, "names"], pos = 2)
## text(1, 1, "wt", pos = 4)
## text(1.2, 1.2, "A", pos = 2)
## text(1.4, 1.2, "B", pos = 2)
@ 


Here, $S_A, S_B < 0$, $S_B < 0$, $S_{AB} > 0$ and $(1 + S_{AB}) (1 + S_A) (1 +
S_B) > 1$.

As before, we can specify this in several different ways. The simplest is
to specify all genotypes:
<<>>=
sa <- -0.6
sb <- -0.7
sab <- 0.3
m1b1 <- allFitnessEffects(epistasis = c("A:-B" = sa,
                                        "-A:B" = sb,
                                        "A:B" = sab))
evalAllGenotypes(m1b1, order = FALSE, addwt = TRUE)
@ 

We could also use a tree and modify the ``sab'' for the epistasis, as
before (\ref{misra1a}).



\subsubsection{Example 1.c}\label{misra1c}

The final case, in figure 1.c, is just epistasis, where a mutation in one
of the genes is deleterious (possibly only mildly), in the other is
beneficial, and the double mutation has fitness larger than any of the
other two.


<<echo=FALSE>>=

df1 <- data.frame(x = c(1, 1.2, 1.2, 1.4), f = c(1, 1.2, 0.7, 1.5),
                 names = c("wt", "A", "B", "AB"))
plot(df1[, 2] ~ df1[, 1], axes = FALSE)
segments(1, 1, 1.2, 1.2)
segments(1, 1, 1.2, 0.7)
segments(1.2, 1.2, 1.4, 1.5)
segments(1.2, 0.7, 1.4, 1.5)
text(x = df1[, 1], y = df1[, 2], labels = df1[, "names"], pos = 2)
## text(1, 1, "wt", pos = 4)
## text(1.2, 1.2, "A", pos = 2)
## text(1.4, 1.2, "B", pos = 2)
@ 

Here we have that $S_A > 0$, $S_B < 0$, $(1 + S_{AB}) (1 + S_A) (1 +
S_B) > (1 + S_{AB})$ so $S_{AB} > \frac{-S_B}{1 + S_B}$


As before, we can specify this in several different ways. The simplest is
to specify all genotypes:
<<>>=
sa <- 0.2
sb <- -0.3
sab <- 0.5
m1c1 <- allFitnessEffects(epistasis = c("A:-B" = sa,
                                        "-A:B" = sb,
                                        "A:B" = sab))
evalAllGenotypes(m1c1, order = FALSE, addwt = TRUE)
@ 

We could also use a tree and modify the ``sab'' for the epistasis, as
before (\ref{misra1a}).



\subsection{Ochs and Desai, 2015}\label{ochsdesai}

In \cite{xx} Ochs and Desai present a model that we can represent as (the
actual numerical values are arbitrarily set by me):


<<echo=FALSE>>=

df1 <- data.frame(x = c(1, 2, 3, 4), f = c(1.1, 1, 0.95, 1.2),
                 names = c("u", "wt", "i", "v"))
plot(df1[, 2] ~ df1[, 1], axes = FALSE, xlab = "", ylab = "")
par(las = 1)
axis(2)
axis(1, at = c(1, 2, 3, 4), labels = df1[, "names"], ylab = "")
box()
arrows(c(2, 2, 3), c(1, 1, 0.95),
       c(1, 3, 4), c(1.1, 0.95, 1.2))
## text(1, 1, "wt", pos = 4)
## text(1.2, 1.2, "A", pos = 2)
## text(1.4, 1.2, "B", pos = 2)
@

In their model, $S_u > 0$, $S_v > S_u$, $S_i < 0$, we can only arrive at
$v$ from $i$, and the mutants ``ui'' and ``uv'' can never appear as their
fitness is 0, or $-\infty$, so $S_{ui} = S_{uv} = -1$.

We can specify this combining a graph and epistasis specifications:

<<>>=
su <- 0.1
si <- -0.05
fvi <- 1.2 ## the fitnes of the vi mutant
sv <- (fvi/(1 + si)) - 1
sui <- suv <- -1
od <- allFitnessEffects(
    data.frame(parent = c("Root", "Root", "i"),
               child = c("u", "i", "v"),
               s = c(su, si, sv),
               sh = -1,
               typeDep = "MN"),
    epistasis = c(
        "u:i" = sui,
        "u:v" = suv))
@ 

A figure showing that model is
<<>>=
plot(od)
@ 

And the fitness of all genotype is
<<>>=
evalAllGenotypes(od, order = FALSE, addwt = TRUE)
@ 


\subsection{Weissman et al., 20xx}
In their figure 1a, Weisman et al. \cite{xx} present this model

\subsubsection{Figure 1.a}

<<echo=FALSE>>=
df1 <- data.frame(x = c(1, 2, 3), f = c(1, 0.95, 1.2),
                 names = c("wt", "1", "2"))
plot(df1[, 2] ~ df1[, 1], axes = FALSE, xlab = "", ylab = "")
par(las = 1)
axis(2)
axis(1, at = c(1, 2, 3), labels = df1[, "names"], ylab = "")
box()
segments(c(1, 2), c(1, 0.95),
       c(2, 3), c(0.95, 1.2))
## text(1, 1, "wt", pos = 4)
## text(1.2, 1.2, "A", pos = 2)
## text(1.4, 1.2, "B", pos = 2)
@

where the ``1'' and ``2'' refer to the number of mutations in two
different loci. This is, therefore, very similar to the example in section
\ref{misra1b}. Here we have $\delta_1 < 0$, fitness of single ``A'' or
single ``B'' = $1 + \delta_1$, $S_{AB} > 0$,
$(1 + S_{AB})(1 + \delta_1)^2 > 1$.


\subsubsection{Figure 1.b}\label{weis1b}

In their figure 1b they show

<<echo=FALSE>>=
df1 <- data.frame(x = c(1, 2, 3, 4), f = c(1, 0.95, 0.92, 1.2),
                 names = c("wt", "1", "2", "3"))
plot(df1[, 2] ~ df1[, 1], axes = FALSE, xlab = "", ylab = "")
par(las = 1)
axis(2)
axis(1, at = c(1, 2, 3, 4), labels = df1[, "names"], ylab = "")
box()
segments(c(1, 2, 3), c(1, 0.95, 0.92),
       c(2, 3, 4), c(0.95, 0.92, 1.2))
## text(1, 1, "wt", pos = 4)
## text(1.2, 1.2, "A", pos = 2)
## text(1.4, 1.2, "B", pos = 2)
@

Where, as before, 1, 2, 3, denote the number of mutations in three
different loci and $\delta_1 < 0$, $\delta_2 < 0$, fitness of single
mutant is $(1 + \delta_1)$, of double mutant is $(1 + \delta_2)$ so that
$(1 + \delta_2) = (1 + \delta_1)^2 (1 + s_2)$ and of triple mutant is
$(1 + \delta_3)$, so that
$(1 + \delta_3) = (1 + \delta_1)^3 (1 + s_2)^3 (1 + s_3)$.


We can specify this combining a graph with epistasis:

<<>>=

d1 <- -0.05 ## single mutant fitness 0.95
d2 <- -0.08 ## double mutant fitness 0.92
d3 <- 0.2   ## triple mutant fitness 1.2

s2 <- ((1 + d2)/(1 + d1)^2) - 1
s3 <- ( (1 + d3)/((1 + d1)^3 * (1 + s2)^3) ) - 1

w <- allFitnessEffects(
    data.frame(parent = c("Root", "Root", "Root"),
               child = c("A", "B", "C"),
               s = d1,
               sh = -1,
               typeDep = "MN"),
    epistasis = c(
        "A:B" = s2,
        "A:C" = s2,
        "B:C" = s2,
        "A:B:C" = s3))
@ 

The model can be shown graphically as:
<<>>=
plot(w)
@ 

And fitness of all genotypes is:

<<>>=
evalAllGenotypes(w, order = FALSE, addwt = TRUE)
@ 



Alternative, we can directly specify what each genotype adds to the
fitness, given the included genotype. This is basically replacing the
graph by giving each of ``A'', ``B'', and ``C'' directly:

<<>>=
wb <- allFitnessEffects(
    epistasis = c(
        "A" = d1,
        "B" = d1,
        "C" = d1,
        "A:B" = s2,
        "A:C" = s2,
        "B:C" = s2,
        "A:B:C" = s3))

evalAllGenotypes(wb, order = FALSE, addwt = TRUE)
@ 

The plot, of course, is not very revealing:

<<>>=
plot(wb)
@ 

As we have seen several times already (sections \ref{e2}, \ref{e3},
\ref{theminus}) we can also give the genotypes directly and, consequently,
the fitness of each genotype (not the added contribution):

<<>>=
wc <- allFitnessEffects(
    epistasis = c(
        "A:-B:-C" = d1,
        "B:-C:-A" = d1,
        "C:-A:-B" = d1,
        "A:B:-C" = d2,
        "A:C:-B" = d2,
        "B:C:-A" = d2,
        "A:B:C" = d3))
evalAllGenotypes(wc, order = FALSE, addwt = TRUE)
@ 





\section{xx: FIXME to add}

\begin{itemize}
\item Some of the module examples of Raphael
\item The model in McFarland
\item Some model from Gerstung, PLoS ONE
\item Ditto for bionifo
\item Some model for the Polaris, Caprese, and Capri examples.
\item Some model for Farahani
\end{itemize}


%% \subsection{Testing of mappings}

%% The mapping of restriction tables, epistasis, and order effects to
%% fitness, especially when there are modules, is a delicate part of the
%% code: reasonable cases are straightforward to deal with, but there are
%% many ways to shoot oneself in the foot. That is why we have placed lots of
%% pre- and post-condition checks in the code (both R and C++), and we have a
%% comprehensive set of tests in file zz. You are welcome to suggest more
%% tricky scenarios (and tests for them).


%% \section{Introduction}

%% This vignette presents the OncoSimulR package. OncoSimulR allows you to
%% simulate tumor progression using several models of tumor progression. In
%% these simulations you can restrict the order in which mutations can
%% accumulate. For instance, you can restrict the allowed order as specified,
%% for instance, in Oncogenetic Tree (OT; \cite{Desper1999JCB, Szabo2008}) or
%% Conjunctive Bayesian Network (CBN; \cite{Beerenwinkel2007, Gerstung2009,
%%   Gerstung2011}) models. Moreover, you can add passenger mutations to the
%% simulations. The models so far implemented are all continuous time models,
%% which are simulated using the BNB algorithm of Mather et
%% al.\ \cite{Mather2012}. This is a summary of some of the key features:


%% \begin{itemize}
%% \item You can pass arbitrary restrictions as specified by OTs or CBNs.
  
%% \item You can add passenger mutations.
  
%% \item You can allow for deviations from the OT and CBN models, specifying
%%   a penalty for such deviations (the $s_h$ parameter).
  
%% \item Right now, three different models are available, two that lead to
%%   exponential growth, one of them loosely based on Bozic et al.\
%%   \cite{Bozic2010}, and another that leads to logistic-like growth, based
%%   on McFarland et al.\ \cite{McFarland2013}.
%% \item Simulations are generally very fast as I use the BNB algorithm
%%   implemented in C++.
%% \end{itemize}


%% Further details about the motivation for wanting to
%% simulate data this way can be found in \cite{ot-biorxiv}, where additional
%% comments about model parameters and caveats are discussed. The Java
%% program by \cite{Reiter2013a} offers somewhat similar functionality, but
%% they are restricted to at most four drivers, you cannot use arbitrary CBNs
%% or OTs to specify order restrictions, there is no allowance for
%% passengers, and a single type of model (a discrete time Galton-Watson
%% process) is implemented.





%% Using this package will often involve the following steps:

%% \begin{enumerate}
%% \item Specify the restrictions in the order of mutations: section \ref{poset}.
%% \item Simulate cancer progression: section \ref{simul}. You can simulate
%%   for a single subject or for a set of subjects. You will need to
%%   \begin{itemize}
%%   \item Decide on a model (e.g., Bozic or McFarland).
%%   \item Specify the parameters of the model.
%%   \end{itemize}
%%   Of course, at least for initial playing around, you can use the defaults.
  
%% \item Sample from the simulated data: section \ref{sample}, and do
%%   something with those simulated data (e.g., fit an OT model to
%%   them). What you do with the data, however, is outside the scope of this
%%   package.   
%% \end{enumerate}


%% Before anything else, let us load the package. We also explicitly load
%% \Biocpkg{graph} for the vignette to work (you do not need that for your
%% usual interactive work).

%% <<>>=
%% library(OncoSimulR)
%% library(graph)
%% @ 


%% \section{Specifying restrictions: posets}\label{poset}

%% How to specify the restrictions is shown in the help for
%% \Rfunction{poset}. It is often useful, to make sure you did not make any
%% mistakes, to plot the poset. This is from the examples (we use an ``L''
%% after a number so that the numbers are integers, not doubles; we could
%% alternatively have modified \texttt{storage.mode}).

%% <<fig.height=3>>=
%% ## Node 2 and 3 depend on 1, and 4 depends on no one
%% p1 <- cbind(c(1L, 1L, 0L), c(2L, 3L, 4L))
%% plotPoset(p1, addroot = TRUE)
%% @ 

%% <<fig.height=3>>=
%% ## A simple way to create a poset where no gene (in a set of 15) depends
%% ## on any other.
%% p4 <- cbind(0L, 15L)
%% plotPoset(p4, addroot = TRUE)
%% @ 



%% Specifying posets is actually straightforward. For instance, we can
%% specify the pancreatic cancer poset in Gerstung et al.\
%% \cite{Gerstung2011} (their figure 2B, left). We specify the poset using
%% numbers, but for nicer plotting we will use names (KRAS is 1, SMAD4 is 2,
%% etc). This example is also in the help for \Rfunction{poset}:

%% <<fig.height=3>>=
%% pancreaticCancerPoset <- cbind(c(1, 1, 1, 1, 2, 3, 4, 4, 5),
%%                                c(2, 3, 4, 5, 6, 6, 6, 7, 7))
%% storage.mode(pancreaticCancerPoset) <- "integer"
%% plotPoset(pancreaticCancerPoset,
%%           names = c("KRAS", "SMAD4", "CDNK2A", "TP53",
%%                     "MLL3","PXDN", "TGFBR2"))
%% @
%% \section{Simulating cancer progression}\label{simul}


%% We can simulate the progression in a single subject. Using an example
%% very similar to the one in the help:


%% <<echo=FALSE,results='hide',error=FALSE>>=
%% options(width=60)
%% @ 

%% <<>>=
%% ## use poset p1101
%% data(examplePosets)
%% p1101 <- examplePosets[["p1101"]]

%% ## Bozic Model
%% b1 <- oncoSimulIndiv(p1101, keepEvery = 15)
%% summary(b1)
%% @ 


%% The first thing we do is make it simpler (for future examples) to use a
%% set of restrictions. In this case, those encoded in poset p1101. Then, we
%% run the simulations and look at a simple summary and a plot. %% We explicitly
%% %% set \texttt{silent = TRUE} to prevent the vignette from filling up with
%% %% intermediate output.

%% If you want to plot the trajectories, it is better to keep more frequent
%% samples,  so you can see when clones appear:

%% <<fig.height=5, fig.width=5>>=
%% b2 <- oncoSimulIndiv(p1101, keepEvery = 1)
                    
%% summary(b2)
%% plot(b2)
%% @ 


%% The following is an example where we do not care about passengers, but we
%% want to use a different graph, and we want a few more drivers before
%% considering cancer has been reached. And we allow it to run for longer.
%% Note that in the McF model \texttt{detectionSize} really plays no
%% role. Note also how we pass the poset: it is the same as before, but now
%% we directly access the poset in the list of posets.

%% <<>>=

%% m2 <- oncoSimulIndiv(examplePosets[["p1101"]], model = "McFL", 
%%                      numPassengers = 0, detectionDrivers = 8, 
%%                      mu = 5e-7, initSize = 4000, 
%%                      sampleEvery = 0.025,
%%                      finalTime = 25000, keepEvery = 5, 
%%                      detectionSize = 1e6) 
%% plot(m2, addtot = TRUE, log = "")

%% @ 


%% The default is to simulate progression until a simulation reaches cancer
%% (i.e., only simulations that satisfy the detectionDrivers or the
%% detectionSize will be returned). If you use the McF model with large
%% enough \texttt{initSize} this will often be the case but not if you use
%% very small \texttt{initSize}. Likewise, most of the Bozic runs do not
%% reach cancer. Lets try a few:

%% <<>>=
%% b3 <- oncoSimulIndiv(p1101, onlyCancer = FALSE)
%% summary(b3)

%% b4 <- oncoSimulIndiv(p1101, onlyCancer = FALSE)
%% summary(b4)
%% @ 

%% Plot those runs:

%% <<fig.width=8, fig.height=4>>=
%% par(mfrow = c(1, 2))
%% par(cex = 0.8) ## smaller font
%% plot(b3)
%% plot(b4)
%% @ 


%% \subsection{Simulating progression in several subjects}

%% To simulate the progression in a bunch of subjects (we will use only
%% four, so as not to fill the vignette with plots) we can do, with the same
%% settings as above:

%% <<>>=
%% p1 <- oncoSimulPop(4, p1101)
%% par(mfrow = c(2, 2))
%% plot(p1)
%% @ 


%% \section{Sampling from a set of simulated subjects}\label{sample}
%% \label{sec:sampling-from-set}

%% You will often want to do something with the simulated data. For instance,
%% sample the simulated data. Here we will obtain the trajectories for 100
%% subjects in a scenario without passengers. Then we will sample with the
%% default options and store that as a vector of genotypes (or a matrix of
%% subjects by genes):


%% <<>>=

%% m1 <- oncoSimulPop(100, examplePosets[["p1101"]], 
%%                    numPassengers = 0)

%% @ 

%% The function \Rfunction{samplePop} samples that object, and also gives you
%% some information about the output:

%% <<>>=
%% genotypes <- samplePop(m1)
%% @ 



%% What can you do with it? That is up to you. As an example, let us try to
%% infer an oncogenetic tree (and plot it) using the \CRANpkg{Oncotree}
%% package \cite{Oncotree} after getting a quick look at the marginal
%% frequencies of events:

%% <<fig.width=4, fig.height=4>>=
%% colSums(genotypes)/nrow(genotypes)

%% require(Oncotree)
%% ot1 <- oncotree.fit(genotypes)
%% plot(ot1)
%% @ 

%% Your run will likely differ from mine, but with the defaults (detection
%% size of $10^8$) it is likely that events down the tree will never
%% appear. You can set \texttt{detectionSize = 1e9} and you will see that
%% events down the tree are now found in the cross-sectional sample.


%% Alternatively, you can use single cell sampling and that, sometimes,
%% recovers one or a couple more events.

%% <<fig.width=4, fig.height=4>>=
%% genotypesSC <- samplePop(m1, typeSample = "single")
%% colSums(genotypesSC)/nrow(genotypesSC)

%% ot2 <- oncotree.fit(genotypesSC)
%% plot(ot2)
%% @ 

%% You can of course rename the columns of the output matrix to something
%% else if you want so the names of the nodes will reflect those potentially
%% more meaningful names.


\section{Session info and packages used}

This is the information about the version of R and packages used:
<<>>=
sessionInfo()
@ 

%\newpage
%%\bibliographystyle{apalike} %% or agsm or natbib? or apalike; maybe agsm
%% does the URL without turning into note?

%\bibliographystyle{apalike} %% or agsm or natbib? or apalike; maybe agsm
\bibliography{OncoSimulR}

\end{document}




%% remember to use bibexport to keep just the minimal bib needed
%% bibexport -o extracted.bib OncoSimulR.aux
%% rm OncoSimulR.bib
%% mv extracted.bib OncoSimulR.bib
%% and then turn URL of packages into notes

%%% Local Variables:
%%% TeX-master: t
%%% ispell-local-dictionary: "en_US"
%%% coding: iso-8859-15
%%% End:




